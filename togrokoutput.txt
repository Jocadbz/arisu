===== ./main.go =====
package main

import (
    "bufio"
    "bytes"
    "encoding/json"
    "fmt"
    "os"
    "os/exec"
    "path/filepath"
    "strings"
    "io"
)

// main is the entry point of the program.
func main() {
    // Define config file path
    configDir := filepath.Join(os.Getenv("HOME"), ".config", "arisu")
    configFile := filepath.Join(configDir, "config.json")

    // Load API key from JSON config
    apiKey := loadAPIKey(configFile)
    if apiKey == "" {
        fmt.Print("Enter your Gemini API key: ")
        scanner := bufio.NewScanner(os.Stdin)
        if scanner.Scan() {
            apiKey = scanner.Text()
        }
        if apiKey == "" {
            fmt.Println("Error: No API key provided.")
            return
        }
        // Save the entered key to JSON config
        saveAPIKey(configFile, apiKey)
    }

    // Initialize Gemini client
    client := NewClient(apiKey)

    // Handle command-line arguments
    args := os.Args[1:]
    if len(args) > 0 {
        // Single prompt mode
        prompt := strings.Join(args, " ")
        response, err := client.SendMessage(prompt)
        if err != nil {
            fmt.Printf("Error: %v\n", err)
            return
        }
        fmt.Println(response)
        handleCommands(response, client)
        return
    }

    // Interactive chat mode
    fmt.Println("For multi-line input, end with a blank line.")
    scanner := bufio.NewScanner(os.Stdin)
    for {
        fmt.Print("$ ")
        var inputLines []string

        // Collect lines until a blank line is entered
        for {
            if !scanner.Scan() {
                return // Exit on EOF or error
            }
            line := scanner.Text()

            // Check for exit condition
            if line == "exit" {
                fmt.Println("Goodbye!")
                return
            }

            // Blank line signals the end of input
            if line == "" {
                break
            }

            // Add the line to the buffer
            inputLines = append(inputLines, line)
        }

        // Skip if no input was provided
        if len(inputLines) == 0 {
            continue
        }

        // Combine all lines into a single string with newlines
        input := strings.Join(inputLines, "\n")

        // Send the input to the API
        response, err := client.SendMessage(input)
        if err != nil {
            fmt.Printf("Error: %v\n", err)
            continue
        }

        fmt.Println(response)
        handleCommands(response, client)
    }
}

// handleCommands detects and executes bash commands in <RUN> tags.
// handleCommands detects and executes bash commands in <RUN> tags.
func handleCommands(response string, client *Client) {
    commands := extractCommands(response)
    for _, command := range commands {
        fmt.Printf("Detected command: %s\n", command)
        fmt.Print("Execute? (y/n): ")

        reader := bufio.NewReader(os.Stdin)
        confirm, _ := reader.ReadString('\n')
        confirm = strings.TrimSpace(confirm)

        if confirm == "y" {
            // Buffer to capture the command output
            var outputBuf bytes.Buffer
            // Set up the command
            cmd := exec.Command("bash", "-c", command)
            // Stream stdout to both terminal and buffer
            cmd.Stdout = io.MultiWriter(os.Stdout, &outputBuf)
            // Stream stderr to both terminal and buffer
            cmd.Stderr = io.MultiWriter(os.Stderr, &outputBuf)
            // Run the command
            err := cmd.Run()
            if err != nil {
                fmt.Printf("Command failed with error: %v\n", err)
            }
            // Retrieve the captured output
            output := outputBuf.String()
            // Add output to conversation context
            client.AddMessage("user", "Command output: "+output)
        } else {
            fmt.Println("Command not executed.")
        }
    }
}

// extractCommands extracts bash commands between <RUN> and </RUN> tags.
func extractCommands(response string) []string {
    var commands []string
    start := 0
    for {
        startIdx := strings.Index(response[start:], "<RUN>")
        if startIdx == -1 {
            break
        }
        startIdx += start
        endIdx := strings.Index(response[startIdx:], "</RUN>")
        if endIdx == -1 {
            break
        }
        endIdx += startIdx
        command := strings.TrimSpace(response[startIdx+5 : endIdx])
        commands = append(commands, command)
        start = endIdx + 6
    }
    return commands
}

// loadAPIKey reads the API key from the JSON config file.
func loadAPIKey(configFile string) string {
    data, err := os.ReadFile(configFile)
    if err != nil {
        return "" // File doesn’t exist or can’t be read
    }
    var config struct {
        GeminiAPIKey string `json:"gemini_api_key"`
    }
    if err := json.Unmarshal(data, &config); err != nil {
        return "" // Invalid JSON
    }
    return config.GeminiAPIKey
}

// saveAPIKey writes the API key to the JSON config file.
func saveAPIKey(configFile, apiKey string) {
    config := struct {
        GeminiAPIKey string `json:"gemini_api_key"`
    }{
        GeminiAPIKey: apiKey,
    }
    data, err := json.MarshalIndent(config, "", "  ")
    if err != nil {
        fmt.Printf("Error encoding config: %v\n", err)
        return
    }
    if err := os.MkdirAll(filepath.Dir(configFile), 0700); err != nil {
        fmt.Printf("Error creating config directory: %v\n", err)
        return
    }
    if err := os.WriteFile(configFile, data, 0600); err != nil {
        fmt.Printf("Error saving config: %v\n", err)
    }
}
===== ./gemini.go =====
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "runtime"
)

// Message represents a single message in the conversation.
type Message struct {
    Role    string `json:"role"`
    Content string `json:"content"`
}

// Part represents a part of the content in the API request/response.
type Part struct {
    Text string `json:"text"`
}

// Content represents a message with a role and parts.
type Content struct {
    Role  string `json:"role"`
    Parts []Part `json:"parts"`
}

// ChatRequest is the structure for sending messages to the API.
type ChatRequest struct {
    Contents []Content `json:"contents"`
}

// ChatResponse is the structure for parsing API responses.
type ChatResponse struct {
    Candidates []struct {
        Content Content `json:"content"`
    } `json:"candidates"`
    Error struct {
        Message string `json:"message"`
    } `json:"error,omitempty"`
}

// Client manages the Gemini API interaction and conversation state.
type Client struct {
    apiKey   string
    messages []Message
}

// NewClient initializes the client with an API key and an initial prompt.
func NewClient(apiKey string) *Client {
    initialPrompt := fmt.Sprintf(
        "This conversation is running inside a terminal session on %s.\n\n"+
            "To better assist me, I'll let you run bash commands on my computer.\n\n"+
            "To do so, include, anywhere in your answer, a bash script, as follows:\n\n"+
            "<RUN>\nshell_script_here\n</RUN>\n\n"+
            "For example, to create a new file, you can write:\n\n"+
            "<RUN>\ncat > hello.ts << EOL\nconsole.log(\"Hello, world!\")\nEOL\n</RUN>\n\n"+
            "And to run it, you can write:\n\n"+
            "<RUN>\nbun hello.ts\n</RUN>\n\n"+
            "I will show you the outputs of every command you run.\n\n"+
            "Keep your answers brief and to the point. Don't include unsolicited details.",
        runtime.GOOS,
    )
    return &Client{
        apiKey:   apiKey,
        messages: []Message{{Role: "user", Content: initialPrompt}},
    }
}

// SendMessage sends a user input to the Gemini API and returns the response.
func (c *Client) SendMessage(input string) (string, error) {
    // Add user message to context
    c.messages = append(c.messages, Message{Role: "user", Content: input})

    // Prepare request payload with roles
    var contents []Content
    for _, msg := range c.messages {
        role := msg.Role
        if role == "assistant" {
            role = "model" // Gemini uses "model" for assistant
        }
        contents = append(contents, Content{
            Role:  role,
            Parts: []Part{{Text: msg.Content}},
        })
    }

    reqData := ChatRequest{Contents: contents}
    data, err := json.Marshal(reqData)
    if err != nil {
        return "", fmt.Errorf("error encoding payload: %v", err)
    }

    // Build and send HTTP request
    url := fmt.Sprintf("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=%s", c.apiKey)
    req, err := http.NewRequest("POST", url, bytes.NewBuffer(data))
    if err != nil {
        return "", fmt.Errorf("error creating request: %v", err)
    }
    req.Header.Set("Content-Type", "application/json")

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return "", fmt.Errorf("error in request: %v", err)
    }
    defer resp.Body.Close()

    // Read raw response body
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return "", fmt.Errorf("error reading response: %v", err)
    }

    // Check status
    if resp.StatusCode != http.StatusOK {
        var errResp ChatResponse
        if err := json.Unmarshal(body, &errResp); err == nil && errResp.Error.Message != "" {
            return "", fmt.Errorf("error %d: %s", resp.StatusCode, errResp.Error.Message)
        }
        return "", fmt.Errorf("error: API returned %d - %s", resp.StatusCode, string(body))
    }

    // Parse response
    var respData ChatResponse
    if err := json.Unmarshal(body, &respData); err != nil {
        return "", fmt.Errorf("error decoding response: %v - Raw response: %s", err, string(body))
    }

    if len(respData.Candidates) > 0 && len(respData.Candidates[0].Content.Parts) > 0 {
        assistantMsg := respData.Candidates[0].Content.Parts[0].Text
        c.messages = append(c.messages, Message{Role: "assistant", Content: assistantMsg})
        return assistantMsg, nil
    }
    return "", fmt.Errorf("error: No response from Gemini - Raw response: %s", string(body))
}

// AddMessage adds a message to the conversation context.
func (c *Client) AddMessage(role, content string) {
    c.messages = append(c.messages, Message{Role: role, Content: content})
}
===== ./README.md =====
# Arisu

My personal script for running gemini on the terminal.

There are safer and better alternatives, so please don't do use this.

Prompt borrowed from Victor Taelin's AI-scripts.

Everything here is public domain.
===== ./go.mod =====
module github.com/arisu

go 1.24.0

